
#ifndef __ma_allocator__
#define __ma_allocator__

#include <cstdlib>
#include <new>
#include <vector>

namespace MultiArrayHelper
{

    template <typename T, size_t N>
    struct Allocator
    {
	typedef T value_type;
	static constexpr type_size = sizeof(value_type);	
	
	Allocator() = default;

	template <typename U>
	Allocator(const Allocator<U>& x) {}

	T* allocate(size_t n)
	{
	    //constexpr size_t NN = N*type_size;
	    const size_t nn = n*type_size;
	    if(n > static_cast<size_t>(-1-NN)) throw std::bad_alloc();
	    auto p = static_cast<char*>(std::malloc(nn + N));
	    if(not p) throw std::bad_alloc();
	    auto ip = static_cast<std::intptr_t>(p);
	    mDiff = N - (ip % N);
	    p += mDiff;
	    return static_cast<T*>(p);
	}

	void deacllocate(T* p, size_t n)
	{
	    std::free(p-mDiff);
	}
	
    private:
	std::intptr_t mDiff;
    };

    template <class T, class U>
    bool operator==(const Allocator<T>& a, const Allocator<T>& b)
    {
	return true;
    }

    template <class T, class U>
    bool operator!=(const Allocator<T>& a, const Allocator<T>& b)
    {
	return false;
    }

    template <typename T>
    using vector = vector<T,Allocator>;
    
} // namespace MultiArrayHelper

#endif
